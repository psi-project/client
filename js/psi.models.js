/*
 * PSI Models (Backbone models for representing PSI resources)
 * 
 * Author: James Montgomery (james.montgomery at anu.edu.au)
 * 
 * Developed as part of the Protocols and Structures for Inference project: http://psi.cecs.anu.edu.au
 */

define(['jquery','underscore','backbone','psi.client','psi.schema','localstorage'], function($, _, Backbone, client, schema) {
	var module = {};

	//--Utility classes for AJAX calls-----------------------------------------

	/**
	 * Basic success and error callbacks for use with fetch().
	 * successMessage (string) and markDirtyOnError (boolean) are optional.
	 */
	var FetchCallbacks = module.FetchCallbacks = function FetchCallbacks(errorMessage, successMessage, markDirtyOnFail, additionalSuccessCallback) {
		if ( !(this instanceof FetchCallbacks) ) { throw new Error("Constructor called as a function"); }
		this.markDirty = markDirtyOnFail;
		this.success = function (model) {
			client.showSuccess(successMessage); 
			if (additionalSuccessCallback) additionalSuccessCallback(model);
		};
		this.error = function (model, response) {
			if (this.markDirty)
				model.dirty = true;
			client.showError(errorMessage, response);
		};
	};

	//--General purpose Model and Collection classes---------------------------

	var uriEndRegex = /\/([^\/]+\/?)$/;
	function getURIEnd(uri) { return uriEndRegex.exec(uri)[1]; }
	
	var PSIModel = module.Model = Backbone.Model.extend({
		psiType: null,
		url: function () { return this.id; },
		uriToID: function () { return this.id.replace(/[:\/\.\~\&\?\=]/g,'_'); },
		/** Subclasses may override this to return a modified URI to which requests should be sent. */
		getRequestURI: function() { return this.id; },
		/** Returns true if the retrieved psiType is OK for this PSIModel; can be overridden to allow a model to handle multiple response psiTypes. */
		psiTypeOK: function(psiType) { return psiType === this.psiType; },
		validate: function (attributes) {
			var keyCount = _.keys(attributes).length;
			if (this.psiType == null || attributes.uri && keyCount == 1 || attributes.uri && attributes.collection && keyCount == 2)
				return;
			if (attributes.psiType === undefined)
				return { message: 'Processed server response does not contain a psiType indicator', response: attributes };
			if (! this.psiTypeOK(attributes.psiType))
				return { message: 'Processed server response type "' + attributes.psiType + '" does not match the expected "' + this.psiType + '"', response: attributes };
		},
		/** Returns a duplicate of the model's attributes hash with an additional id property generated by uriToID(). */
		attributesAndID: function () { return _.extend({ uriID: this.uriToID() }, this.attributes) },
		/** Wrapper for fetch() with default success and error messages. Both arguments optional. */
		refresh: function (markAsDirty, additionalSuccessCallback) {
			client.startWorking();
			
//alert('Refreshing ' + this.id);
			
			this.fetch( new FetchCallbacks('Error refreshing view of ' + this.url(), 'Refreshed view of ' + this.url(), markAsDirty, additionalSuccessCallback) );
		},
		logResponse: function(response) { client.logResponse(response, this.url()); }
	});

	var PSICollection = module.Collection = PSIModel.extend({
		psiType: 'resource-list',
		embeddedResourceKey: 'resources',
		parse: function (response) {
			this.logResponse(response);
			//Replace *list* of resources with a hash to (eventually) the representations of the resources linked to
			var resources = {};
			var labelled = ! _.isArray( response[this.embeddedResourceKey] );
			response.resourceLabels = {};
			_.each( response[this.embeddedResourceKey], function(uri, label) {
				resources[uri] = null;
				if (labelled)
					response.resourceLabels[uri] = label + (/\?/.test(uri) ? /\?.+$/.exec(uri)[0] : '');
				else //Note: assumes that the URI contains at least one slash
					response.resourceLabels[uri] = getURIEnd(uri);
			});
			response.resources = resources; //whatever the list was under, store the hash under .resources
			//Keep already downloaded models (but discard any that are no longer in the server collection
			// Note this means that already downloaded models cannot be internally refreshed by refreshing the list
			if (this.has('resources'))
				_.extend(response.resources, _.pick( this.get('resources'), _.keys(response.resources) ) );
			return response;
		},
		getResource: function (uri, callback) {
			var model = this.get('resources')[uri];
			if (model == null || model.dirty) {
				model = this.get('resources')[uri] = this._newModel(uri);
				client.startWorking();
				model.refresh(true, callback);
			} else if (callback) {
				callback(model);
			}
			return model;
		},
		/** Instantiates the new model and sets its id and 'collection' properties; may be overridden to add additional properties. */
		_newModel: function(uri) {
			return new this.resourceModel({id: uri, collection: this}).on('destroy', this.refresh, this);
		},
		getSchemaCompiler: function () {
			return this.has('psi') ? this.get('psi').getSchemaCompiler() : client.getSchemaCompiler();
		}
	});

	
	//----Requests and Responses-----------------------------------------------

	var PSIRequest = module.Request = Backbone.Model.extend({	
		//Allows the form to have the requisite target URI included in it without including it in the message sent to the server
		initialize: function () {
			this.uri = this.get('uri'); // for convenience elsewhere, forms use a hidden 'uri' field rather than 'id'
			this.unset('uri');
			this.url = function () { return this.uri; };
		},
		/**
		 * Posts this request object to its URI, then intercepts the success
		 * and error callbacks, checks the status code against the hash of
		 * alternative callbacks in options and calls the matching one if found,
		 * or the original general success or error functions if not.
		 */
		postRequest: function (options) {
			var uri = this.url();
			if (options) {
				var error = options.error;
				var success = options.success;
				options.error = function (jqXHR, textStatus, errorThrown) { options._delegate(jqXHR.responseText, jqXHR, error); };
				options.success = function (data, textStatus, jqXHR) { options._delegate(data, jqXHR, success); };
				options._delegate = function (response, jqXHR, fallback) {
					var headerOnly = !response && jqXHR.getResponseHeader('location');
					if (headerOnly)
						response = { 'Status' : jqXHR.status, 'Location' : jqXHR.getResponseHeader('location') };
					client.logResponse(response, uri, headerOnly);
					if (options[jqXHR.status])
						options[jqXHR.status](response, jqXHR);
					else if (fallback)
						fallback(response, jqXHR);
				};
			}
			//If even one request will result in a 300 redirection then can't use Backbone, since it doesn't seem to follow the redirect (after all, it's not expecting to, right?). Also, can't specify content type as browser doesn't seem satisfied with response to preflight OPTIONS request and refuses to follow redirect that's issued later.
			client.logRequest(this.attributes, uri);
			$.ajax(_.extend({ type: 'POST', url: uri, data: JSON.stringify(this.attributes), dataType: 'json', /*contentType: 'application/json',*/ processData: false}, options));
		}
	});

	/**
	 * The value response, represented as a model so can be fetched via
	 * Backbone. For attributes, initialize with { instance: <all|n> }, while
	 * for transformers initialise with { input: <some_value> } (this avoids
	 * the name conflict with the ultimate response.
	 */
	var ValueModel = module.ValueModel = PSIModel.extend({
		initialize: function() {
			if (this.has('uri')) { this.id = this.get('uri'); this.unset('uri'); }
			if (this.has('instance'))
				this.set({ argName : 'instance', argValue: this.get('instance'), label: 'Instance'});
			else
				this.set({ argName : 'value', argValue: this.get('input'), label: 'Input'});
		},
//		parse: function(response) { return _.extend(response, this.attributes); },
		url : function() {
			return this.id + (this.id.indexOf('?') >= 0 ? '&' : '?') + this.get('argName') + '=' + this.get('argValue');
		},
		getInput: function() { return this.get('argValue'); }
	});

	//----Schema---------------------------
	
	var SchemaModel = module.SchemaModel = PSIModel.extend({
		url: function () { return this.id + '?template=true'; },
		/** Sole purpose is to be able to display the server's response */
		parse: function(response) {
			this.logResponse(response);
			return response;
		},
		asPrettyString: function () {
			return client.ppJSON( this.omit('collection') );
		}
	});
	
	var SchemasModel = module.SchemasModel = PSICollection.extend({
		resourceModel: SchemaModel
	});
	
	//----To support collections of joins based on different models----------
	
	/**
	 * A PSICollection to hold resource-to-resource joins whose URIs are kept
	 * in localStorage. When creating an instance, include an 'owner' instance,
	 * which is the actual PSI resource to which the joins belong and set the
	 * 'resourceModel' property directly on the object to indicate the class of
	 * PSIModels the collection will hold.
	 */
	var ModelJoins = module.ModelJoins = PSICollection.extend({
		initialize: function() {
			if (!this.has('resources'))
				this.set({resources: {}, resourceLabels: {}}, { silent: true });
			this.set('psiType', ModelJoins.prototype.psiType, { silent: true });
		},
		/**
		 *  While PSICollection relies on the resource-list coming from the
		 *  server, this collection allows new entries. 
		 */
		addJoin: function(uri) {
			this.get('resources')[uri] = null;
			this.get('resourceLabels')[uri] = getURIEnd(uri);
			this.save();
		},
		deleteJoin: function(uri) {
			delete this.get('resources')[uri];
			delete this.get('resourceLabels')[uri];
			this.save();
		},
		_newModel: function(uri) {
			//Unlike a PSICollection retrieved from the server, won't refresh() when model is 'destroyed'
			return new this.resourceModel({ id: uri, collection: this.get('owner').get('collection'), owner: this.get('owner') });
		},
		toJSON: function() {
			return { id: this.id, resources: _.keys(this.get('resources')) };
		}
	});

	/**
	 * A collection of ModelJoins created on the client's machine. Models are
	 * stored with some information missing (such as an owner object and their
	 * resourceModel property, which is restored by the JoinableModelMixIn
	 * mix-in.
	 */
	module.JoinsCollection = Backbone.Collection.extend({
		model: ModelJoins,
		localStorage: new Backbone.LocalStorage("psi-join-collection")
	});
	
	//Store the JoinsCollection instance in the PSI client
	client.getJoinStore = function () {
		if (!this.joinStore) {
			this.joinStore = new module.JoinsCollection();
			this.joinStore.fetch();
		}
		return this.joinStore;  
	};
	
	/**
	 * To use this mix-in, set the 'ownType' property to the same as the type
	 * this is being mixed into, since each join will have the same type.
	 */  
	var JoinableModelMixIn = module.JoinableModelMixIn = {
		_idURI: function() { return this.id.replace(/\?.*$/,''); },
		
		getRequestURI: function() {
			var owner = this._getJoinOwner();
			return this.id +
				(owner != this && /\?/.test(owner.getRequestURI()) ? '&' + /\?(.*)$/.exec(owner.getRequestURI())[1] : '');
		},
		isJoin: function() { return this.has('owner'); },
		/** Returns true if this model has associated joins. Must be called before any attempt is made to read joins, since it will also retrieve them from localStorage. */
		hasJoins: function() {
			if (this.isJoin()) return false;
			if (!this.has('joins')) {
				var entry = client.getJoinStore().get(this._idURI());
				if (entry)
					this.set({ joins: this.createModelJoins(entry) }, {silent: true}); //let other events indicate model change
			}
			return this.has('joins');
		},
		getJoins: function() { return this._getJoinOwner().get('joins'); },
		recordJoin: function(joinURI) {
			if (this.isJoin()) {
				this._getJoinOwner().recordJoin(joinURI);
			} else {
				if (!this.hasJoins()) {
					this.set({ joins: this.createModelJoins()}, {silent: true} ); //trigger change once new join added
					client.getJoinStore().add( this.get('joins') );
				}
				this.get('joins').addJoin(joinURI);
				if (this.trigger) this.trigger('change');
			}
		},
		removeJoin: function(joinURI) {
			if (this.isJoin()) {
				this._getJoinOwner().removeJoin(joinURI);
			} else {
				this.get('joins').deleteJoin(joinURI);
				if (this.trigger) this.trigger('change');
			}
		},
		destroy: function(options) {
			options.wait = true; //really have to know that deletion was successful before PSICollection is notified
			if (!this.isJoin() && this.has('joins'))
				this.get('joins').destroy();
			Backbone.Model.prototype.destroy.call(this, options);
		},
		createModelJoins: function(existingEntry) {
			var joinOwner = this._getJoinOwner();
			var modelJoins = existingEntry ? existingEntry.set( {owner:joinOwner}, {silent:true} ) : new ModelJoins({ id: this._idURI(), owner: joinOwner});
			modelJoins.resourceModel = this.ownType; //type of contained model is set directly on a PSICollection
			return modelJoins;
		},
		_getJoinOwner: function() { return this.get('owner') || this; }
	};
	
	//----Relations and Attributes---------

	var AttributeModel = module.AttributeModel = PSICollection.extend({
		psiType: 'attribute',
		embeddedResourceKey: 'subattributes',
		initialize: function () {
			this.resourceModel = AttributeModel;
			this.ownType = AttributeModel;
			_.extend(this, JoinableModelMixIn);
		},
		parse: function (response) {
			if (response.subattributes) {
				//Transfer subattribute URI list to resources map (and make .subattributes an alias for resources, too)
				PSICollection.prototype.parse.call(this, response);
				response.subattributes = response.resources;
			} else {
				this.logResponse(response);
			}
			return response;
		}
	});
	
	var AttributeJoinsModel = module.AttributeJoinsModel = ModelJoins.extend({
		resourceModel: AttributeModel
	});
	
	//Is both a model of a relation and collection of attributes
	var RelationModel = module.RelationModel = PSICollection.extend({
		psiType: 'relation',
		embeddedResourceKey: 'attributes',
		resourceModel: AttributeModel,
		url: function () {
			return this.id + (this.has('query') && this.get('query').length > 0 ? '?' + this.get('query') : '');
		},
		parse: function (response) {
			//Transfer attribute URI list to resources map (and make .attributes an alias for resources, too)
			PSICollection.prototype.parse.call(this, response);
			response.attributes = response.resources;
			//Split uri from query string, if present
			var queryMatches = response.uri.match(/\?.*$/);
			response.query = queryMatches ? queryMatches[0].substring(1) : '';
//FIXME Check that this correct changes the model's id/URI or if that must be done directly (this.id rather than response.id)
			response.id = response.uri.replace(/\?.*$/, '');
            if (this.has('querySchema')) { //already compiled; use that version
				response.querySchema = this.get('querySchema');
			} else {
				var querySchema = response.querySchema;
				delete response.querySchema; //remove until compiled
	            var model = this;
            	$.when( this.getSchemaCompiler().compile(querySchema) )
	                .done( function (s) { model.set({ querySchema: schema.addTitlesToProperties(s), queryArgs: schema.query2Args(response.query, s) }); })
	                .fail( function (e) { model.set({ queryError: e }); } );
			}
			return response;
		},
		applyQuery: function (query) {
			if (query !== this.get('query'))
				this._applyQuery(query, schema.query2Args(query, this.querySchema));
		},
		applyQueryArgs: function (queryArgs) {
			if (!_.isEqual(queryArgs, this.get('queryArgs')))
				this._applyQuery(schema.args2Query(queryArgs), queryArgs);
		},
		_applyQuery: function (query, queryArgs) {
			this.set({ query: query, queryArgs: queryArgs });
			this.refresh();
		},
		createAttribute: function (createAttrReq) {
			var req = new PSIRequest(createAttrReq);
			var model = this;
			req.postRequest({
				error: function (response) { client.showError('Error creating new attribute', response); },
				'201': function (response, jqXHR) {
					model.refresh();
					client.showMessageDialog('Attribute created successfully at ' + jqXHR.getResponseHeader('Location'));
				}
			});
		}
	});
	
	var RelationsModel = module.RelationsModel = PSICollection.extend({
		resourceModel: RelationModel
	});

	//----Learners-------------------------
	
	var LearnerModel = module.LearnerModel = PSIModel.extend({
		psiType: 'learner',
		parse: function (response) {
			this.logResponse(response);
			var resAndParamsSchema = { '/resources': response.taskSchema['/resources'] };
			response.paramsSchema = _.clone(response.taskSchema);
			delete response.paramsSchema['/resources'];
			if (!_.isEmpty(response.paramsSchema)) {
				//Since repackaging parameters in own object, must decide if at least one parameter is required and hence parameters object is required
				var parametersPrefix = '?';
				_.each(response.paramsSchema, function(s, prop) { if (prop.charAt(0) === '/') parametersPrefix = '/'; });
				resAndParamsSchema[parametersPrefix + 'parameters'] = response.paramsSchema;
			}

			//Instigate compilation of those into JSON schema, but set the properties
			//on the model, since won't be ready by time this function returns. Note
			//that fail() will, at the moment, only be called when 'expected' errors,
			// such as bad predefined schema references, are encountered. Malformed
			// JSON will not be caught by the compiler.
			var model = this;
			var c = this.has('collection') ? this.get('collection').getSchemaCompiler() : client.getSchemaCompiler();
			$.when( c.compile(resAndParamsSchema) )
				.done( function (s) { model.set({ resourcesJSONSchema: $.extend(true, {}, s.properties.resources),
										taskJSONSchema: schema.addTitlesToProperties( model.resourcesAsRefs(s) ) }); })
				.fail( function (e) { model.set({ schemaError: e }); } );

			return response;
		},

		jobStarted: function (statusURI) {
			//FIXME How should jobs be dealt with if learner is loaded stand-alone?
			if (this.has('collection') && this.get('collection').has('psi'))
				this.get('collection').get('psi').addJob( statusURI );
		},

		/**
		 * Modifies the 'type' property of the properties of the top-level
		 * 'resources' property in the given schema to be 'string'. Returns
		 * given schema object.
		 */
		resourcesAsRefs: function (taskJSONSchema) {
			//Note that this may not be robust, although any deviation from what it expects would likely cause problems in other parts of a PSI system, so it should be safe enough
			//Note that for draft v4 schema the compiled schema for resource representations will contain a 'required' property that, under v3 could be considered 'truthy' and hence prevent the '(optional)' label from being added
			_.each(taskJSONSchema.properties.resources.properties, function (s, k, props) {
				props[k] = _.omit(s, 'required', 'allOf', 'anyOf', 'oneOf', 'noneOf'); //also remove indirect validation constraints
				props[k].type = 'string';
				props[k].format = 'uri'; //tv4 doesn't yet respect this, but probably will in the future
			});
			return taskJSONSchema;
		},
		/**
		 * Moves data.params properties into data (and removes params key) and
		 * adds '$' prefix to any resource property values if present, then
		 * moves whole structure apart from psiType into 'task' element.
		 */
		resourcesAndParamsToTask: function (data) {
			_.each( data.resources, function (v, k, res) { if (v.charAt(0) !== '$') res[k] = '$'+v; } );
			data.task = _.extend(_.pick(data, 'resources'), data.parameters ? data.parameters : {});
			delete data.resources;
			delete data.parameters;
			return data;
		}
	});
	
	var LearnersModel = module.LearnersModel = PSICollection.extend({
		resourceModel: LearnerModel
	});
	
	//----Statuses-------------------------

	var StatusModel = module.StatusModel = PSIModel.extend({
		//FIXME There is no longer a guaranteed Status resource, although predictors may return an alternative status representation
		psiType: 'training-status',
		psiTypeOK: function(psiType) { return psiType === this.psiType || psiType === 'transformer'; },
//FIXME _Some_ way to detect error conditions would be useful (this is old approach that will not longer work)
		isError: function () { return this.get('complete') && ! this.has('predictor'); },
		isComplete: function() { return this.model.get('psiType') === 'transformer'; }
	});

	/** No equivalent collection in the PSI service; this is a local cache of ongoing jobs. */
	var JobsModel = module.JobsModel = PSICollection.extend({
		resourceModel: StatusModel,
		initialize: function () {
			this.set({ psiType: 'resource-list', resources: {}, resourceLabels: {} }); //since this isn't coming from the server
		},
		addJob: function (uri) {
			this.get('resources')[uri] = null; //as per usual, will be fetched when first accessed
			this.get('resourceLabels')[uri] = getURIEnd(uri);
			this.trigger('change');
		}	
	});

	//----Transformers and Predictors-----------------------
	
	//FIXME Adapt into new PSI transformer/predictor model
	
	var TransformerModel = module.TransformerModel = PSIModel.extend({
		psiType: 'transformer',
		initialize: function() {
			//These are both to support joins
			this.ownType = TransformerModel;
			_.extend(this, JoinableModelMixIn);		
		},
		
		parse: function(response) {
			this.logResponse(response);
			var model = this;
			var c = model.has('collection') && model.get('collection').has('psi') ? model.get('collection').get('psi').getSchemaCompiler() : client.getSchemaCompiler();
			$.when( c.compile( response.accepts ))
				.done( function(s) { model.set({ acceptsSchema: s }); } )
				.fail( function (e) { client.showError('Unable to compile transformer\'s accepts schema so will be unable to validate submitted values', e); } );
			if (response.update) {
				$.getJSON( response.update, function(updateSchema) {
					$.when( c.compile(updateSchema) )
						//FIXME Performs some fiddly post-processing to make form amenable to jsonform; will not work on complicated update schema (or extremely simple schema that define a single atomic value)
						.done( function (s) {
							var jsonFields = [];
							_.each(s.properties, function(pSchema, p) {
								if (pSchema.type === 'array') {
									jsonFields.push(p);
									pSchema.description = 'Must match this PSI schema: ' + JSON.stringify(updateSchema['/'+p]); //give PSI schema for field as description
									pSchema.type = 'string';
								}
							});
							model.set({ updateSchema: s, updateFormSchema: schema.addTitlesToProperties(s), updateFormJsonFields: jsonFields });
						})
						.fail( function (e) { client.showError('Although predictor is updatable, was unable to compile its update schema to generate an appropriate form', e); } );
				});
			}
			return response;
		}
	});
	
	var TransformersModel = module.TransformersModel = PSICollection.extend({
		resourceModel: TransformerModel
	});
	
	/* Create aliases for predictors so that, when it is known that they are predictors, not general purpose transformers, can represented them differently. */
	var PredictorModel = module.PredictorModel = TransformerModel.extend({
		initialize: function() {
			//These are both to support joins
			this.ownType = PredictorModel;
			_.extend(this, JoinableModelMixIn);		
		}
	});
	
	var PredictorsModel = module.PredictorsModel = PSICollection.extend({
		resourceModel: PredictorModel
	});
	
	
	//----PSI Service(s)-------------------
	
	var ServiceModel = module.ServiceModel = PSICollection.extend({
		psiType: 'service',
		/** Create a jobs collection if none exists and add the given status resource to it. */
		addJob: function (uri) {
			if (!this.has('jobs'))
				this.set({ jobs: new JobsModel({ psi: this }) });
			this.get('jobs').addJob(uri);
		},
		parse: function (response) {
			this.logResponse(response);
			var service = this;
			response.resourceLabels = _.invert( _.pick(response, 'relations', 'learners', 'predictors', 'transformers', 'schema') );
			_.each(['relations','learners','predictors','transformers','schema'], function(c) {
				if (response[c])
					response[c] = new (module.collectionNameToModelClass(c))({id: response[c], psi: service});
			});

			var toFetch = _.filter(response, function (field) { return (field instanceof PSIModel); } );
			//Support the inherited getResource and other PSICollection methods by adding all models to a resources field, too
			response.resources = {};
			_.each(toFetch, function(model) { response.resources[model.id] = model; });

			var done = 0, errors = [], serviceURI = this.id;
			var reportOutcome = function () {
				done++;
				if (done < toFetch.length) return;
				if (errors.length == 0) {
					client.showSuccess('Connected to PSI service at ' + serviceURI);
				} else {
					client.showError('Error loading resource collection(s) from:<br/>' +
						_.pluck(errors, 'uri').join(', ') + '<br/>The respective responses were:<br/>' + _.pluck(errors, 'response'));
				}
			};
			client.startWorking();
			_.each(toFetch, function (field){
				field.fetch({
					success: reportOutcome,
					error: function (model, response) {
						errors.push({ uri: field.id, response: response });
						reportOutcome();
					}
				});
			});
			return response;
		},
		
		getSchemaCompiler: function () {
			//defaults to the PSI project demonstration service's schema root
			return client.getSchemaCompiler( this.has('schema') ? this.get('schema').id : 'http://poseidon.cecs.anu.edu.au/schema' );
		}
	});

	/**
	 * Utility function for obtaining a human-readable label for a PSI
	 * response (may be the same as the original psiType).
	 */
	module.responseToName = function(r) {
		var rt = r.psiType;
		if (rt === 'service') return 'PSI service';
		else if (rt === 'resource-list') return 'PSI resource list';
		else if (rt === 'transformer') return r.update ? 'updatable predictor' : 'transformer';
		return rt;
	};

	/**
	 * Utility function for obtaining the appropriate PSI Model subclass for
	 * the given response, such as RelationModel given
	 * { "psiType": "relation", ... }.
	 */
	module.responseToModelClass = function(r) {
		var rt = r.psiType;
		if (rt === 'service') return ServiceModel;
		else if (rt === 'relation') return RelationModel;
		else if (rt === 'attribute') return AttributeModel;
		else if (rt === 'transformer') return TransformerModel;
		else if (rt === 'learner') return LearnerModel;
		else if (rt === 'resource-list') return Collection; //FIXME But never actually want to create this without knowing what it contains
		throw new Error('Unknown or unsupported model type: ' + rt);
	};
	
	/**
	 * Utility for obtaining the appropriate PSI collection type for the given
	 * collection name appearing in a 'service' psiType.
	 */
	module.collectionNameToModelClass = function(c) {
		if (c === 'relations') return RelationsModel;
		else if (c === 'learners') return LearnersModel;
		else if (c === 'predictors') return PredictorsModel; //use alias as may wish to distinguish between them later
		else if (c === 'transformers') return TransformersModel;
		else if (c === 'schema') return SchemasModel;
		throw new Error('Unknown top-level PSI collection name: ' + c);
	};

	/** A convenience to have a collection of services *as if it were itself a resource*. */
	module.ServicesModel = PSICollection.extend({
		SERVICE_LOADED: 'serviceloaded',
		resourceModel: ServiceModel,
		serviceCount: 0,
		initialize: function () {
			this.set({ psiType: 'resource-list', resources: {}, resourceLabels: {} }); //since this isn't coming from the server
		},
		contains: function(uri) { return _.has(this.get('resources'), uri); },
		/** Attempts to add the PSI resource represented by the given response to this service collection. */
		addResource: function(response) {
			//FIXME TODO Decide what additional processing is done on retrieved models to see if it is actually worth reusing the response obtained in order to check that a given URI is a PSI resource.
			this.addService(response.uri, module.responseToModelClass(response), module.responseToName(response));
		},
		/** Attempts to retrieve the (top-level) PSI service from the given URI. */
		addService: function(uri, whatModel, whatLabel) {
			client.startWorking();
			whatModel = whatModel || ServiceModel;
			whatLabel = whatLabel || 'service';
			var service = new whatModel( { id: uri } );
			var collection = this;
			service.fetch( {
				success: function(model) {
					collection.get('resources')[uri] = model;
					collection.get('resourceLabels')[uri] = uri;
					collection.serviceCount++;
					collection.trigger(collection.SERVICE_LOADED, model, collection.serviceCount);
					collection.trigger('change');
					client.showSuccess();
				},
				error: function(model, response) { client.showError('Error loading ' + whatLabel, response); }
			});
		},
		removeResource: function(uri) {
			if (! this.get('resources')[uri])
				throw new Error('Attempt to remove PSI resource that was not previously added to the collection: ' + uri);
			delete this.get('resources')[uri];
			this.serviceCount--;
			this.trigger('change');
		}
	});

	return module;
});
